# Plan 约束与反思优化实施计划

## 背景分析

基于 Trace `251e5073-04e6-4116-bd8d-6c523d3b2e20` 的深度分析，发现两个核心问题：

### 问题 1: 工具约束未充分利用
- **现状**: StructuredPlan 虽有 `tool_constraints` 字段，但在 Plan 生成阶段未被充分应用
- **影响**: LLM 在执行过程中可以自由选择非预期工具（如 Step 3 使用 `fetch_web_content`）
- **根因**: `structured_planner.py` 生成 Plan 时，没有根据任务类型自动推断工具约束

### 问题 2: 反思触发过晚
- **现状**: 只在达到 `max_iterations` (10 次) 时才触发反思
- **影响**: Step 4 停滞时，`tool_execution_count` 从 4 增加到 8，但无干预机制
- **根因**: 缺少多维度反思触发条件（Step 停滞、工具重复、进展缓慢）

---

## 优化方案

### Optimization 3: 添加工具约束到 StructuredPlan

#### P3-1: 增强工具约束自动生成逻辑
**文件**: `backend/src/orchestrator/structured_planner.py`

**修改位置**: Line 109-191 (`generate` 方法)

**改动内容**:
1. 添加任务类型识别（研究类、创作类、数据处理类等）
2. 根据任务类型预设工具白名单/黑名单
3. 在 prompt 中显式强调工具约束

**示例规则**:
```python
TASK_TYPE_RULES = {
    "research": {
        "allowed": ["web_search", "fetch_web_content", "memory"],
        "forbidden": ["pdf", "pptx"],
        "keywords": ["研究", "分析", "调查", "趋势"]
    },
    "creation": {
        "allowed": ["pdf", "pptx", "write_file"],
        "forbidden": [],
        "keywords": ["生成", "创建", "撰写", "制作"]
    },
    "data_processing": {
        "allowed": ["read_file", "write_file", "run_in_terminal"],
        "forbidden": ["web_search"],
        "keywords": ["转换", "处理", "分析", "统计"]
    }
}
```

**预期效果**: 
- 研究类任务自动禁止 PDF/PPT 工具
- 创作类任务自动包含对应生成工具
- 减少工具偏离率 80%+

---

#### P3-2: 改进 LLM Prompt 强调工具约束
**文件**: `backend/src/orchestrator/structured_planner.py`

**修改位置**: Line 30-97 (`SYSTEM_PROMPT`)

**改动内容**:
在 prompt 中添加明确的工具约束说明：

```python
## 重要规则
1. 必须为每个步骤指定明确的工具
2. 如果任务类型是"研究报告"，工具只能使用：web_search, fetch_web_content, memory
3. 最后一步必须是生成工具（pdf/pptx/write_file）
4. 禁止在早期步骤使用生成工具
```

**预期效果**: LLM 生成的 Plan 步骤更明确，工具选择更合理

---

#### P3-3: 在 PlanContext 中记录工具约束使用情况
**文件**: `backend/src/orchestrator/plan_context.py`

**修改位置**: Line 17-43 (`PlanState` dataclass)

**改动内容**:
添加字段追踪工具约束违反情况：

```python
@dataclass
class PlanState:
    # ... 现有字段 ...
    tool_violations: list[dict] = field(default_factory=list)  # 工具违反记录
    allowed_tools_snapshot: list[str] = field(default_factory=list)  # 允许的工具快照
```

**预期效果**: 可追溯工具违反历史，便于调试和优化

---

### Optimization 4: 提前触发反思

#### P4-1: 添加 Step 停滞检测机制
**文件**: `backend/src/orchestrator/react_loop.py`

**修改位置**: Line 1474-1506 (新增方法)

**改动内容**:
添加新的反思触发条件检测方法：

```python
def _should_step_stuck_reflect(
    self,
    iteration: int,
    plan_state: Any,
    strategy_state: StrategyState
) -> bool:
    """判断是否因 Step 停滞需要反思
    
    触发条件:
    1. current_step 连续 3 次迭代未变化
    2. tool_execution_count > 3 且仍在同一 Step
    3. 同一工具重复调用 >= 2 次
    """
```

**集成位置**: Line 529 (`_should_reflect_on_result` 之后)

**预期效果**: 在 Step 4 停滞时（tool_execution_count=3）即触发反思，而非等到 8 次

---

#### P4-2: 增加工具重复检测灵敏度
**文件**: `backend/src/orchestrator/react_loop.py`

**修改位置**: Line 1372-1374

**改动内容**:
降低反思触发阈值：

```python
# 当前
elif state.same_tool_repeated >= self.MAX_SAME_TOOL_REPEATS:  # MAX_SAME_TOOL_REPEATS=5

# 改进
elif state.same_tool_repeated >= 2:  # 降低到 2 次
    analysis["primary_reason"] = "检测到工具调用循环"
    analysis["recommendation"] = "请立即停止重复调用，尝试不同方法或进入下一步"
```

**预期效果**: 更早发现工具循环模式

---

#### P4-3: 添加进度缓慢检测
**文件**: `backend/src/orchestrator/react_loop.py`

**修改位置**: Line 1493-1506 (扩展 `_should_long_task_reflect`)

**改动内容**:
增加更多检查点：

```python
def _should_long_task_reflect(self, iteration: int, max_iterations: int, plan_state: Any = None) -> bool:
    # 原有逻辑：1/3 和 2/3 处检查
    checkpoints = [max_iterations // 3, (max_iterations * 2) // 3]
    
    # 新增：如果有 plan_state，添加额外检查
    if plan_state and hasattr(plan_state, 'current_step'):
        # 每 2 次迭代检查一次进展
        if iteration % 2 == 0 and iteration > 0:
            if not hasattr(self, '_last_step_snapshot'):
                self._last_step_snapshot = plan_state.current_step
            elif self._last_step_snapshot == plan_state.current_step:
                return True  # 2 次迭代无进展
            else:
                self._last_step_snapshot = plan_state.current_step
    
    return iteration in checkpoints
```

**预期效果**: 每 2 次迭代无进展即触发反思

---

#### P4-4: 在 ReAct Loop 主循环中集成多维度反思
**文件**: `backend/src/orchestrator/react_loop.py`

**修改位置**: Line 393-530 (主循环)

**改动内容**:
在每次迭代后检查多种反思条件：

```python
for iteration in range(self.max_iterations):
    # ... 现有代码 ...
    
    # 执行工具后，检查是否需要反思
    result = await self.tool_manager.execute(...)
    
    # 多维度反思检查
    should_reflect = False
    reflection_reason = ""
    
    # 1. 结果异常反思（已有）
    should_reflect, reflection_type, reason = self._should_reflect_on_result(result)
    if should_reflect:
        reflection_reason = reason
    
    # 2. Step 停滞反思（新增）
    if plan_state and self._should_step_stuck_reflect(iteration, plan_state, strategy_state):
        should_reflect = True
        reflection_reason = f"Step 停滞检测：current_step={plan_state.current_step}, tool_execution_count={plan_state.tool_execution_count}"
    
    # 3. 工具重复反思（增强）
    if strategy_state.same_tool_repeated >= 2:  # 降低阈值
        should_reflect = True
        reflection_reason = f"工具重复检测：{strategy_state.last_tool_name} 已调用 {strategy_state.same_tool_repeated} 次"
    
    # 4. 进度缓慢反思（扩展）
    if self._should_long_task_reflect(iteration, self.max_iterations, plan_state):
        should_reflect = True
        reflection_reason = "进度缓慢检测：连续 2 次迭代无进展"
    
    if should_reflect and self.enable_reflection:
        # 触发反思流程
        yield {
            "type": REACT_EVENT_REFLECTION,
            "reflection_type": ReflectionType.STRATEGY_ADJUSTMENT.value,
            "content": reflection_reason,
            "suggestion": "请重新评估当前策略，考虑：1) 简化方法；2) 进入下一步；3) 寻求用户帮助",
        }
```

**预期效果**: 多维度实时监控，提前发现并纠正问题

---

#### P4-5: 添加反思注入消息增强
**文件**: `backend/src/orchestrator/react_loop.py`

**修改位置**: Line 338-368 (Plan 执行监控)

**改动内容**:
当检测到反思触发时，注入更强的引导消息：

```python
if should_reflect:
    # 添加系统引导消息
    reflection_guidance = (
        f"\n\n⚠️ **反思触发**\n"
        f"原因：{reflection_reason}\n"
        f"建议操作:\n"
        f"1. 如果正在重复同一工具 → 立即停止，尝试其他方法\n"
        f"2. 如果 Step 停滞 → 评估是否可以进入下一步\n"
        f"3. 如果工具偏离 → 回顾计划中的工具约束\n"
        f"4. 如果任务困难 → 考虑分解为更小的子任务\n"
    )
    
    working_messages.append({
        "role": "system",
        "content": reflection_guidance,
    })
```

**预期效果**: 不仅触发反思，还提供具体的纠正建议

---

## 实施顺序

### Phase 1: 工具约束增强 (Optimization 3)
1. **P3-1**: 任务类型识别与工具约束自动生成
2. **P3-2**: LLM Prompt 改进
3. **P3-3**: PlanState 字段扩展

### Phase 2: 提前反思触发 (Optimization 4)
1. **P4-1**: Step 停滞检测
2. **P4-2**: 工具重复检测降阈值
3. **P4-3**: 进度缓慢检测
4. **P4-4**: 多维度反思集成
5. **P4-5**: 反思引导消息增强

### Phase 3: 测试验证
1. 单元测试：每个反思触发条件
2. 集成测试：使用原 Trace 案例验证
3. 对比测试：优化前后效果对比

---

## 预期指标提升

| 指标 | 当前 | 目标 | 改进幅度 |
|------|------|------|----------|
| Plan 执行偏离率 | ~60% | <15% | ↓75% |
| Step 停滞检测延迟 | 8 次迭代 | 3 次迭代 | ↓62% |
| 工具循环发现时间 | 5 次重复 | 2 次重复 | ↓60% |
| 任务完成率 | ~40% | >75% | ↑87% |
| 平均迭代次数 | 10 次 | 5-6 次 | ↓40% |

---

## 风险与缓解

### 风险 1: 反思过早触发导致效率降低
**缓解**: 设置合理的阈值，通过测试调整参数

### 风险 2: 工具约束过严限制 LLM 灵活性
**缓解**: 提供"申请突破约束"机制，LLM 可说明理由后使用非常规工具

### 风险 3: 代码复杂度增加
**缓解**: 添加详细注释和单元测试，保持代码可维护性

---

## 验收标准

1. ✅ 使用原 Trace 案例测试，Step 4 停滞时在 3 次迭代内触发反思
2. ✅ 工具重复调用 2 次后即收到警告
3. ✅ 研究类任务自动禁止使用 PDF/PPT 工具
4. ✅ Plan 生成时每个步骤都明确指定工具
5. ✅ 新 Trace 显示工具偏离率下降 70%+
6. ✅ 所有新增反思触发条件都有对应单元测试

---

## 技术债务清理

实施完成后需要：
1. 更新 `ReAct Loop 五种反思场景规范` 文档
2. 添加 `工具约束配置最佳实践` 示例
3. 清理临时的 debug 日志输出
4. 性能回归测试（确保反思逻辑不显著影响响应时间）