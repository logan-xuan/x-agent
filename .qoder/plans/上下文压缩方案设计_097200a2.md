# 上下文压缩系统设计方案

## 1. 设计目标

1. **批量传递当前会话窗口**：在阈值内，将会话历史批量传递给LLM
2. **高效Token管理**：精准计算和控制token使用量
3. **分段归档机制**：达到阈值时自动触发，保留最近N轮+前段摘要

## 2. 系统架构

### 2.1 核心组件

```
┌─────────────────────────────────────────────────────────────┐
│                 ContextCompressionManager                    │
│  ┌──────────────┐  ┌──────────────────┐  ┌──────────────┐  │
│  │ TokenCounter │  │Compressor        │  │ MdSync       │  │
│  │              │  │                  │  │ (复用现有)   │  │
│  │ - 精准计数   │  │ - 生成摘要       │  │ - 写入今日   │  │
│  │ - 预算管理   │  │ - 保留最近N轮    │  │   记忆       │  │
│  └──────────────┘  └──────────────────┘  └──────────────┘  │
└─────────────────────────────────────────────────────────────┘
                              │
        ┌─────────────────────┴─────────────────────┐
        ▼                     ▼                     ▼
┌───────────────┐    ┌───────────────┐    ┌───────────────┐
│ SessionStore  │    │  Daily Memory │    │   Prompt      │
│  (SQLite)     │    │  (memory/*.md)│    │   Builder     │
│               │    │               │    │               │
│ - messages    │    │ - 摘要        │    │ - 组装上下文  │
│ - metadata    │    │ - 关键事实    │    │ - 注入记忆    │
└───────────────┘    └───────────────┘    └───────────────┘
```

### 2.2 配置模型

```python
# backend/src/config/models.py 扩展
class CompressionConfig(BaseModel):
    """上下文压缩配置"""
    
    # 触发阈值（满足任一即触发）
    threshold_rounds: int = 100   # 对话轮数阈值
    threshold_tokens: int = 4000  # Token数量阈值
    
    # 保留策略
    retention_count: int = 50     # 保留最近N轮对话
```

### 2.3 核心类设计

#### 2.3.1 TokenCounter - Token计数器

```python
# backend/src/services/compression/token_counter.py
import tiktoken

class TokenCounter:
    """精准的Token计数器"""
    
    def __init__(self, encoding_name: str = "cl100k_base"):
        self.encoding = tiktoken.get_encoding(encoding_name)
    
    def count_messages(self, messages: list[dict]) -> int:
        """计算消息列表的token数（OpenAI格式）"""
        total = 0
        for msg in messages:
            total += 4  # 每条消息基础开销
            total += len(self.encoding.encode(msg.get("content", "")))
            total += len(self.encoding.encode(msg.get("role", "")))
        total += 2  # 对话格式开销
        return total
    
    def count_text(self, text: str) -> int:
        """计算文本token数"""
        return len(self.encoding.encode(text))
```

#### 2.3.2 ContextCompressor - 上下文压缩器

```python
# backend/src/services/compression/compressor.py
class ContextCompressor:
    """上下文压缩器 - 混合压缩策略"""
    
    def __init__(self, llm_service: LLMService, token_counter: TokenCounter):
        self.llm = llm_service
        self.token_counter = token_counter
    
    async def compress(
        self,
        messages: list[dict],
        retention_count: int
    ) -> CompressionResult:
        """
        混合压缩策略：
        1. 分离归档区和保留区
        2. 对归档区生成摘要
        3. 保留最近N轮完整原文
        """
        # 1. 分离归档区和保留区
        archive_messages = messages[:-retention_count]
        recent_messages = messages[-retention_count:]
        
        # 2. 生成摘要
        summary = await self._generate_summary(archive_messages)
        
        # 3. 提取关键事实
        key_facts = await self._extract_key_facts(archive_messages)
        
        # 4. 构建压缩后的消息列表
        compressed_messages = self._build_compressed_messages(
            recent_messages, 
            summary
        )
        
        return CompressionResult(
            compressed_messages=compressed_messages,
            recent_messages=recent_messages,
            archived_messages=archive_messages,
            summary=summary,
            key_facts=key_facts,
            original_token_count=self.token_counter.count_messages(messages),
            compressed_token_count=self.token_counter.count_messages(compressed_messages)
        )
    
    async def _generate_summary(self, messages: list[dict]) -> str:
        """使用LLM生成对话摘要"""
        prompt = self._build_summary_prompt(messages)
        response = await self.llm.complete(prompt)
        return response.content
    
    async def _extract_key_facts(self, messages: list[dict]) -> list[str]:
        """提取关键事实"""
        prompt = self._build_fact_extraction_prompt(messages)
        response = await self.llm.complete(prompt)
        return self._parse_facts(response.content)
    
    def _build_compressed_messages(
        self,
        recent_messages: list[dict],
        summary: str
    ) -> list[dict]:
        """构建压缩后的消息列表"""
        compressed = []
        
        # 添加摘要作为系统上下文
        compressed.append({
            "role": "system",
            "content": f"[历史对话摘要]\n{summary}\n\n以上是对话的历史摘要，请结合当前对话理解上下文。"
        })
        
        # 添加保留的最近消息
        compressed.extend(recent_messages)
        
        return compressed
```

#### 2.3.3 ContextCompressionManager - 上下文压缩管理器

```python
# backend/src/services/compression/manager.py
from ..memory.md_sync import MarkdownSync

class ContextCompressionManager:
    """上下文压缩管理器 - 主入口"""
    
    def __init__(self, config: CompressionConfig, workspace_path: str):
        self.config = config
        self.token_counter = TokenCounter()
        self.compressor = ContextCompressor(llm_service, self.token_counter)
        self.md_sync = MarkdownSync(workspace_path)  # 复用现有MdSync
    
    async def prepare_context(
        self,
        session_id: str,
        current_messages: list[dict],
        system_prompt: str
    ) -> PreparedContext:
        """准备上下文 - 主入口方法"""
        
        # 1. 计算当前token使用情况
        total_tokens = self.token_counter.count_messages(current_messages)
        total_tokens += self.token_counter.count_text(system_prompt)
        
        # 2. 检查是否需要压缩
        needs_compression = self._check_compression_needed(
            len(current_messages), 
            total_tokens
        )
        
        if not needs_compression:
            return PreparedContext(
                messages=current_messages,
                total_tokens=total_tokens
            )
        
        # 3. 执行压缩
        return await self._compress_context(session_id, current_messages)
    
    async def _compress_context(
        self,
        session_id: str,
        messages: list[dict]
    ) -> PreparedContext:
        """执行压缩流程"""
        
        # 1. 压缩
        result = await self.compressor.compress(
            messages, 
            self.config.retention_count
        )
        
        # 2. 存储摘要到今日记忆（复用MdSync）
        await self._store_summary_to_daily_memory(
            session_id=session_id,
            summary=result.summary,
            key_facts=result.key_facts,
            archived_count=len(result.archived_messages)
        )
        
        return PreparedContext(
            messages=result.compressed_messages,
            summary=result.summary,
            total_tokens=result.compressed_token_count
        )
    
    async def _store_summary_to_daily_memory(
        self,
        session_id: str,
        summary: str,
        key_facts: list[str],
        archived_count: int
    ):
        """存储摘要到今日记忆文件"""
        from datetime import datetime
        
        today = datetime.now().strftime("%Y-%m-%d")
        
        # 构建记忆条目
        memory_entry = f"""
## 会话 {session_id[:8]}... 上下文压缩归档

**时间**: {datetime.now().isoformat()}
**归档消息数**: {archived_count}

### 摘要
{summary}

### 关键事实
"""
        for fact in key_facts:
            memory_entry += f"- {fact}\n"
        
        # 使用MdSync写入今日记忆
        await self.md_sync.append_to_daily_log(today, memory_entry)
    
    def _check_compression_needed(
        self, 
        message_count: int, 
        token_count: int
    ) -> bool:
        """检查是否需要压缩"""
        return (
            message_count > self.config.threshold_rounds or
            token_count > self.config.threshold_tokens
        )
```

## 3. 压缩策略

### 3.1 触发条件

| 触发类型 | 条件 | 说明 |
|---------|------|------|
| **轮数触发** | 消息数 ≥ threshold_rounds (默认100) | 按计划归档，防止历史过长 |
| **Token触发** | Token数 ≥ threshold_tokens (默认4000) | 应急压缩，防止单次请求超限 |

两种触发条件满足**任一**即执行压缩，处理方式相同。

### 3.2 压缩流程

```
原始消息: [Msg1] [Msg2] ... [Msg50] [Msg51] ... [Msg100]
           └─ 归档区(50条)─┘    └─ 保留区(50条)─┘
                    ↓ 生成摘要          ↓ 保留原文
           ┌─────────────────┐
           │ 摘要: 前50轮讨论 │
           │ 了xxx...        │
           └─────────────────┘
                    ↓
输出: [系统消息: 摘要] + [Msg51完整] ... [Msg100完整]
```

### 3.3 摘要生成Prompt

```
请对以下对话历史生成简洁的摘要：

对话历史：
{messages}

要求：
1. 用3-5句话概括主要内容
2. 保留重要的决策、约定和待办事项
3. 保留用户的关键需求和偏好
4. 使用第三人称客观描述

摘要：
```

### 3.4 关键事实提取Prompt

```
请从以下对话中提取关键事实，每行一个：

对话历史：
{messages}

提取要点：
- 用户偏好（喜好、习惯、风格）
- 重要决策（双方共识、约定）
- 待办事项（未完成任务）
- 关键信息（背景、约束条件）

关键事实（每行一个）：
```

## 4. 存储方案

### 4.1 不复用 conversation_segments 表

**原因**：
- 摘要存储到 `memory/YYYY-MM-DD.md` 即可
- 向量检索复用现有 `vector_store` 模块
- 避免维护额外的表结构

### 4.2 存储位置

| 数据 | 存储位置 | 说明 |
|-----|---------|------|
| 完整消息 | SQLite `messages` 表 | 现有，不变 |
| 摘要 | `memory/YYYY-MM-DD.md` | 今日记忆文件 |
| 关键事实 | `memory/YYYY-MM-DD.md` | 同上 |
| 向量嵌入 | 现有 Vector Store | 复用现有能力 |

### 4.3 今日记忆格式示例

```markdown
---
id: "550e8400-e29b-41d4-a716-446655440000"
date: "2026-02-16"
created_at: "2026-02-16T14:30:00Z"
---

## 会话 abc123... 上下文压缩归档

**时间**: 2026-02-16T14:30:00
**归档消息数**: 50

### 摘要
用户要求实现一个用户认证系统，讨论了使用JWT token的方案，决定采用access token + refresh token的双token机制...

### 关键事实
- 用户偏好使用Python和FastAPI框架
- 决定采用JWT双token机制
- 待办：实现token刷新接口
- 约束：token有效期设置为15分钟
```

## 5. 配置方案

### 5.1 全局配置 (x-agent.yaml)

```yaml
# backend/x-agent.yaml
compression:
  threshold_rounds: 100    # 对话轮数阈值（达到即触发压缩）
  threshold_tokens: 4000   # Token数量阈值（达到即触发压缩）
  retention_count: 50      # 保留最近N轮对话原文
```

### 5.2 配置说明

- **threshold_rounds**: 当会话消息数达到此值时触发压缩
- **threshold_tokens**: 当上下文token数达到此值时触发压缩
- **retention_count**: 压缩时保留的最近对话轮数

## 6. 文件结构

```
backend/src/
├── services/
│   └── compression/
│       ├── __init__.py
│       ├── manager.py          # ContextCompressionManager
│       ├── token_counter.py    # TokenCounter
│       └── compressor.py       # ContextCompressor
├── config/
│   └── models.py               # CompressionConfig
└── memory/
    └── md_sync.py              # 复用现有（增加append_to_daily_log）
```

## 7. 接口设计

### 7.1 内部API

```python
class ContextCompressionManager:
    """上下文压缩管理器"""
    
    async def prepare_context(
        self,
        session_id: str,
        messages: list[dict],
        system_prompt: str
    ) -> PreparedContext:
        """准备上下文，自动触发压缩如果需要"""
        pass
```

### 7.2 数据模型

```python
@dataclass
class CompressionResult:
    """压缩结果"""
    compressed_messages: list[dict]   # 压缩后的消息列表（摘要+保留消息）
    recent_messages: list[dict]       # 保留的最近N轮
    archived_messages: list[dict]     # 被归档的消息
    summary: str                      # 生成的摘要
    key_facts: list[str]              # 提取的关键事实
    original_token_count: int         # 原始token数
    compressed_token_count: int       # 压缩后token数

@dataclass
class PreparedContext:
    """准备好的上下文"""
    messages: list[dict]              # 最终消息列表
    summary: str | None = None        # 摘要（如果有）
    total_tokens: int = 0             # 总token数
```

## 8. 测试方案

### 8.1 单元测试

#### 8.1.1 TokenCounter 测试

```python
# backend/tests/unit/test_token_counter.py
import pytest
from services.compression.token_counter import TokenCounter

class TestTokenCounter:
    """Token计数器测试"""
    
    def setup_method(self):
        self.counter = TokenCounter()
    
    def test_count_single_message(self):
        """测试单条消息计数"""
        messages = [{"role": "user", "content": "Hello world"}]
        count = self.counter.count_messages(messages)
        # 4(基础) + 11(content) + 4(role) + 2(格式) = 21
        assert count > 0
        assert isinstance(count, int)
    
    def test_count_multiple_messages(self):
        """测试多条消息计数"""
        messages = [
            {"role": "user", "content": "Hello"},
            {"role": "assistant", "content": "Hi there!"},
        ]
        count = self.counter.count_messages(messages)
        # 应该比单条多
        single = self.counter.count_messages([messages[0]])
        assert count > single
    
    def test_count_chinese_text(self):
        """测试中文文本计数"""
        messages = [{"role": "user", "content": "你好世界，这是一个测试"}]
        count = self.counter.count_messages(messages)
        # 中文字符通常占1-2个token
        assert count > 0
    
    def test_count_empty_messages(self):
        """测试空消息列表"""
        count = self.counter.count_messages([])
        assert count == 2  # 只有格式开销
    
    def test_count_text(self):
        """测试纯文本计数"""
        text = "Hello world"
        count = self.counter.count_text(text)
        assert count > 0
        assert isinstance(count, int)
```

#### 8.1.2 ContextCompressor 测试

```python
# backend/tests/unit/test_compressor.py
import pytest
from unittest.mock import Mock, AsyncMock
from services.compression.compressor import ContextCompressor, CompressionResult

class TestContextCompressor:
    """上下文压缩器测试"""
    
    def setup_method(self):
        self.mock_llm = Mock()
        self.mock_llm.complete = AsyncMock(return_value=Mock(content="摘要内容"))
        self.mock_token_counter = Mock()
        self.mock_token_counter.count_messages = Mock(return_value=100)
        self.compressor = ContextCompressor(self.mock_llm, self.mock_token_counter)
    
    @pytest.mark.asyncio
    async def test_compress_basic(self):
        """测试基本压缩功能"""
        messages = [
            {"role": "user", "content": f"消息{i}"} 
            for i in range(100)
        ]
        
        result = await self.compressor.compress(messages, retention_count=50)
        
        assert isinstance(result, CompressionResult)
        assert len(result.recent_messages) == 50
        assert len(result.archived_messages) == 50
        assert result.summary is not None
        assert len(result.compressed_messages) == 51  # 摘要 + 50条保留
    
    @pytest.mark.asyncio
    async def test_compress_less_than_retention(self):
        """测试消息数少于保留数的情况"""
        messages = [
            {"role": "user", "content": f"消息{i}"} 
            for i in range(30)
        ]
        
        result = await self.compressor.compress(messages, retention_count=50)
        
        # 归档区为空，全部保留
        assert len(result.archived_messages) == 0
        assert len(result.recent_messages) == 30
    
    @pytest.mark.asyncio
    async def test_build_compressed_messages(self):
        """测试构建压缩后消息列表"""
        recent = [
            {"role": "user", "content": "最近消息1"},
            {"role": "assistant", "content": "回复1"},
        ]
        summary = "这是摘要"
        
        compressed = self.compressor._build_compressed_messages(recent, summary)
        
        assert len(compressed) == 3
        assert compressed[0]["role"] == "system"
        assert "摘要" in compressed[0]["content"]
        assert compressed[1] == recent[0]
        assert compressed[2] == recent[1]
```

#### 8.1.3 ContextCompressionManager 测试

```python
# backend/tests/unit/test_compression_manager.py
import pytest
from unittest.mock import Mock, AsyncMock, patch
from services.compression.manager import ContextCompressionManager
from config.models import CompressionConfig

class TestContextCompressionManager:
    """上下文压缩管理器测试"""
    
    def setup_method(self):
        self.config = CompressionConfig(
            threshold_rounds=100,
            threshold_tokens=4000,
            retention_count=50
        )
        self.manager = ContextCompressionManager(
            config=self.config,
            workspace_path="/tmp/test_workspace"
        )
        # Mock依赖
        self.manager.compressor = Mock()
        self.manager.md_sync = Mock()
    
    def test_check_compression_needed_by_rounds(self):
        """测试按轮数触发压缩"""
        # 101条消息，超过阈值100
        needed = self.manager._check_compression_needed(101, 1000)
        assert needed is True
        
        # 99条消息，未超过阈值
        needed = self.manager._check_compression_needed(99, 1000)
        assert needed is False
    
    def test_check_compression_needed_by_tokens(self):
        """测试按Token触发压缩"""
        # 4500 tokens，超过阈值4000
        needed = self.manager._check_compression_needed(50, 4500)
        assert needed is True
        
        # 3000 tokens，未超过阈值
        needed = self.manager._check_compression_needed(50, 3000)
        assert needed is False
    
    @pytest.mark.asyncio
    async def test_prepare_context_no_compression_needed(self):
        """测试不需要压缩的情况"""
        messages = [{"role": "user", "content": "Hello"}]
        
        with patch.object(
            self.manager.token_counter, 
            'count_messages', 
            return_value=100
        ):
            with patch.object(
                self.manager.token_counter,
                'count_text',
                return_value=50
            ):
                result = await self.manager.prepare_context(
                    session_id="test-session",
                    current_messages=messages,
                    system_prompt="系统提示"
                )
        
        # 直接返回原始消息
        assert result.messages == messages
        assert result.summary is None
    
    @pytest.mark.asyncio
    async def test_store_summary_to_daily_memory(self):
        """测试存储摘要到今日记忆"""
        self.manager.md_sync.append_to_daily_log = AsyncMock()
        
        await self.manager._store_summary_to_daily_memory(
            session_id="test-session",
            summary="测试摘要",
            key_facts=["事实1", "事实2"],
            archived_count=50
        )
        
        # 验证调用了写入方法
        self.manager.md_sync.append_to_daily_log.assert_called_once()
        call_args = self.manager.md_sync.append_to_daily_log.call_args
        assert "测试摘要" in call_args[0][1]
```

### 8.2 集成测试

```python
# backend/tests/integration/test_compression_flow.py
import pytest
from services.compression.manager import ContextCompressionManager
from config.models import CompressionConfig

class TestCompressionFlow:
    """压缩流程集成测试"""
    
    @pytest.mark.asyncio
    async def test_full_compression_flow(self, test_db, test_workspace):
        """测试完整压缩流程"""
        config = CompressionConfig(
            threshold_rounds=10,  # 降低阈值方便测试
            threshold_tokens=1000,
            retention_count=5
        )
        
        manager = ContextCompressionManager(
            config=config,
            workspace_path=test_workspace
        )
        
        # 构造11条消息（超过阈值10）
        messages = [
            {"role": "user" if i % 2 == 0 else "assistant", 
             "content": f"消息内容{i}"}
            for i in range(11)
        ]
        
        result = await manager.prepare_context(
            session_id="test-session",
            current_messages=messages,
            system_prompt=""
        )
        
        # 验证压缩结果
        assert result.summary is not None
        assert len(result.messages) == 6  # 摘要 + 5条保留
        
        # 验证今日记忆文件是否写入
        import os
        from datetime import datetime
        today = datetime.now().strftime("%Y-%m-%d")
        memory_file = os.path.join(test_workspace, "memory", f"{today}.md")
        assert os.path.exists(memory_file)
```

### 8.3 手动测试脚本

```python
# backend/scripts/test_compression.py
"""
手动测试上下文压缩功能

使用方法:
    cd backend
    python scripts/test_compression.py
"""

import asyncio
import sys
from pathlib import Path

sys.path.insert(0, str(Path(__file__).parent.parent))

from services.compression.token_counter import TokenCounter
from services.compression.compressor import ContextCompressor
from services.compression.manager import ContextCompressionManager
from config.models import CompressionConfig

async def test_token_counter():
    """测试Token计数器"""
    print("=" * 50)
    print("测试 TokenCounter")
    print("=" * 50)
    
    counter = TokenCounter()
    
    # 测试英文
    text_en = "Hello world, this is a test message."
    count_en = counter.count_text(text_en)
    print(f"英文文本: '{text_en}'")
    print(f"Token数: {count_en}")
    
    # 测试中文
    text_cn = "你好世界，这是一个测试消息。"
    count_cn = counter.count_text(text_cn)
    print(f"\n中文文本: '{text_cn}'")
    print(f"Token数: {count_cn}")
    
    # 测试消息列表
    messages = [
        {"role": "system", "content": "你是一个助手"},
        {"role": "user", "content": "你好"},
        {"role": "assistant", "content": "你好！有什么可以帮助你的？"},
    ]
    count_msg = counter.count_messages(messages)
    print(f"\n消息列表 Token数: {count_msg}")

async def test_compression_scenarios():
    """测试不同场景的压缩"""
    print("\n" + "=" * 50)
    print("测试压缩场景")
    print("=" * 50)
    
    config = CompressionConfig(
        threshold_rounds=10,
        threshold_tokens=1000,
        retention_count=5
    )
    
    # 场景1: 消息数未达阈值
    print("\n场景1: 消息数未达阈值 (5条 < 10阈值)")
    messages_small = [
        {"role": "user" if i % 2 == 0 else "assistant", 
         "content": f"消息{i}"}
        for i in range(5)
    ]
    counter = TokenCounter()
    token_count = counter.count_messages(messages_small)
    print(f"消息数: {len(messages_small)}, Token数: {token_count}")
    print(f"需要压缩: {len(messages_small) > config.threshold_rounds or token_count > config.threshold_tokens}")
    
    # 场景2: 消息数达到阈值
    print("\n场景2: 消息数达到阈值 (12条 > 10阈值)")
    messages_large = [
        {"role": "user" if i % 2 == 0 else "assistant", 
         "content": f"这是第{i}条消息的内容，包含一些文字用于测试token计数。"}
        for i in range(12)
    ]
    token_count = counter.count_messages(messages_large)
    print(f"消息数: {len(messages_large)}, Token数: {token_count}")
    print(f"需要压缩: {len(messages_large) > config.threshold_rounds or token_count > config.threshold_tokens}")
    
    # 场景3: Token数达到阈值
    print("\n场景3: Token数达到阈值")
    messages_tokens = [
        {"role": "user" if i % 2 == 0 else "assistant", 
         "content": "这是一段很长的文本，" * 50}  # 构造长文本
        for i in range(5)
    ]
    token_count = counter.count_messages(messages_tokens)
    print(f"消息数: {len(messages_tokens)}, Token数: {token_count}")
    print(f"需要压缩: {len(messages_tokens) > config.threshold_rounds or token_count > config.threshold_tokens}")

async def main():
    """主测试函数"""
    print("上下文压缩系统测试")
    print("=" * 50)
    
    await test_token_counter()
    await test_compression_scenarios()
    
    print("\n" + "=" * 50)
    print("测试完成")
    print("=" * 50)

if __name__ == "__main__":
    asyncio.run(main())
```

### 8.4 性能测试

```python
# backend/tests/performance/test_compression_perf.py
import pytest
import time
from services.compression.token_counter import TokenCounter

class TestCompressionPerformance:
    """压缩性能测试"""
    
    def test_token_count_performance(self):
        """测试Token计数性能"""
        counter = TokenCounter()
        
        # 构造1000条消息
        messages = [
            {"role": "user", "content": f"消息内容{i}" * 100}
            for i in range(1000)
        ]
        
        start = time.time()
        count = counter.count_messages(messages)
        elapsed = time.time() - start
        
        print(f"\n1000条消息计数耗时: {elapsed:.3f}s")
        assert elapsed < 1.0  # 应该在1秒内完成
    
    def test_compression_with_large_context(self):
        """测试大上下文压缩性能"""
        # 构造200条长消息
        messages = [
            {"role": "user" if i % 2 == 0 else "assistant",
             "content": "这是一段很长的对话内容，" * 100}
            for i in range(200)
        ]
        
        counter = TokenCounter()
        start = time.time()
        count = counter.count_messages(messages)
        elapsed = time.time() - start
        
        print(f"\n200条长消息计数耗时: {elapsed:.3f}s, Token数: {count}")
        assert elapsed < 2.0
```

### 8.5 测试检查清单

| 测试项 | 类型 | 说明 |
|-------|------|------|
| Token计数准确性 | 单元测试 | 验证中英文、长短文本计数正确 |
| 压缩逻辑正确性 | 单元测试 | 验证归档区/保留区分离正确 |
| 触发条件判断 | 单元测试 | 验证轮数和Token双触发条件 |
| 消息列表构建 | 单元测试 | 验证摘要+保留消息组装正确 |
| 存储集成 | 集成测试 | 验证MdSync写入今日记忆 |
| 完整流程 | 集成测试 | 端到端压缩流程 |
| 大上下文性能 | 性能测试 | 1000+消息处理性能 |
| 边界条件 | 单元测试 | 空消息、单条消息、恰好阈值 |

## 9. 总结

### 9.1 核心设计

1. **单一混合压缩策略**：前段生成摘要 + 保留最近N轮原文
2. **双触发机制**：轮数阈值 或 Token阈值，满足任一即触发
3. **复用现有系统**：
   - 消息存储 → SQLite messages表
   - 摘要存储 → memory/YYYY-MM-DD.md（MdSync）
   - 向量检索 → 现有 vector_store
4. **精简配置**：仅3个核心参数

### 9.2 实施步骤

1. **Phase 1**: 实现 TokenCounter 和 CompressionConfig
2. **Phase 2**: 实现 ContextCompressor（摘要生成+关键事实提取）
3. **Phase 3**: 实现 ContextCompressionManager（触发判断+存储）
4. **Phase 4**: 集成到消息处理流程
